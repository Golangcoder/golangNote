##反射：通过type of 和 value of 的方式，获取结构对象内部的信息。

type of 从字面上就可以看出，是获得接口的类型
value of 获取接口的值

```
package main

import (
    "fmt"
    "reflect"
)

type User struct {
    Id   int
    Name string
    Age  int
}

func (self User) Hello() {
    fmt.Println("hello world")
}
func main() {
    a := User{Name: "Zhanghua", Age: 14, Id: 1}
    Info(a)
}

//如何反射接口的类型，接口的方法，实现该接口的结构的字段和属性，方法
func Info(u interface{}) { //传入接受的是interface空接口，那么，传入的类型可能是多种多样的。如何在方法内部判断是不是我们需要的类型呢？
    r := reflect.TypeOf(u)
    fmt.Println("Type:", r.Name())          //type of获取了接口类型
    if k := r.Kind(); k != reflect.Struct { //使用kind方法，获取传入接口类型
        fmt.Println("Not support Type", k)
        return
    }

    v := reflect.ValueOf(u)

    for i := 0; i < r.NumField(); i++ {
        f := r.Field(i)                                   //通过下标找到字段
        val := v.Field(i).Interface()                     //通过对字段的interface方法找到字段的值
        fmt.Printf("%6s: %v = %v\n", f.Name, f.Type, val) //字段.Name 字段.Type获取字段的名称和类型
    }
    for i := 0; i < r.NumMethod(); i++ {
        m := r.Method(i)
        fmt.Printf("%6s: %v", m.Name, m.Type)
    }
}

/*
    Type: User
        Id: int = 1
      Name: string = Zhanghua
       Age: int = 14
     Hello: func(main.User)
*/

```
使用kind来判断接口的类型，那么，从reflect源码中，找到支持的类型有：
```
const (
    Invalid Kind = iota
    Bool
    Int
    Int8
    Int16
    Int32
    Int64
    Uint
    Uint8
    Uint16
    Uint32
    Uint64
    Uintptr
    Float32
    Float64
    Complex64
    Complex128
    Array
    Chan
    Func
    Interface
    Map
    Ptr
    Slice
    String
    Struct
    UnsafePointer
)
```
如果传入的接口类型不对，那么调用错误的接口方法将导致pannic。所以，在接口传入后，应判断接口的类型，再进一步获取或者更改接口信息。

##反射匿名字段或者嵌入字段